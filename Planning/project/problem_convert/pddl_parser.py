import sys

from lark import Lark, Transformer, v_args
from Planning.project.generator.state_to_json import parse_state
from Planning.project.solver.ffx.plan_to_json import parse_plan


class Predicate:
    def __init__(self, name='', args='9'):
        self.name = name
        self.args = args

    def mlnCap(self):
        return self.name + '(' + ', '.join(list(map(lambda x: x.capitalize(), self.args))) + ')'

    def mln(self):
        return self.name + '(' + ', '.join(self.args) + ')'

    def __copy__(self):
        return Predicate(self.name, self.args)

    def __hash__(self):
        return hash(self.name + str(self.args))

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __str__(self):
        return " ".join((self.name, ": ", " ".join(self.args)))


class Action:
    arg_locations = dict()

    def __init__(self, name='', args='', precondition='', effect=dict):
        self.name = name
        self.args = args
        self._set_arg_locations()
        self.precondition = precondition
        self.pos = self._get_predicates(effect['positive'])
        self.neg = self._get_predicates(effect['negative'])

    def _set_arg_locations(self):
        self.arg_locations = dict()
        for i, a in enumerate(self.args):
            self.arg_locations[a] = i

    def get_pos_list(self, args):
        return self.get_list(self.pos, args)

    def get_neg_list(self, args):
        return self.get_list(self.neg, args)

    def get_list(self, eff_list, args):
        """
        applies predicate on the positive/neg effects of an action
        and returns the list of predicates that are generated by said action.
        """
        if len(args) < len(self.args):
            raise Exception(
                "Arguments do not match Action footprint,\n expecting: " + str(self.args) + " | got: " + str(args))
        l = set()

        for p in eff_list:
            pc = p.__copy__()
            pc.args = list(map(lambda x: args[x], list(map(lambda y: self.arg_locations[y], p.args))))
            l.add(pc)
            print(l)
        return l

    def _get_predicates(self, effect):
        l = []
        for p in effect:
            l.append(Predicate(**p))
        return l

    def __hash__(self):
        return hash(str(self.name) + str(self.args))


class State:
    actions = dict()

    def __init__(self, state):
        self._set_actions(state['actions'])
        self.state = set()

    def perform_action(self, p: Predicate):
        print(self)
        pos = self.actions[p.name].get_pos_list(p.args)
        self.state = self.state | pos
        neg = self.actions[p.name].get_neg_list(p.args)
        self.state = self.state - neg
        print(len(self.state))

    def _set_actions(self, actions):
        for a in actions:
            self.actions[a['name']] = Action(**a)

    def set_init_state(self, predicate_json):
        for p in predicate_json:
            self.state.add(Predicate(**p))

    def mlnCap(self):
        s = ''
        for p in self.state:
            s += '\n' + p.mlnCap()
        return s

    def mln(self):
        s = ''
        for p in self.state:
            s += '\n' + p.mln()
        return s

    def __str__(self):
        for p in self.state:
            return str(p)


class PddlToJson(Transformer):
    def pddl(self, args):
        domain = args[0]
        predicates = args[1]
        actions = args[2:]
        return {'domain': domain, 'predicates': predicates, 'actions': actions}

    def string(self, s):
        return s

    def predicates(self, p_list):
        return p_list

    def predicate(self, args):
        name = args[0][0].value
        vals = list(tuple(args[1:]))
        p = {'name': name, 'args': vals}
        return p

    def var(self, v):
        val = v[0][0].value
        return val

    def parameters(self, args):
        return list(args)

    def definition(self, name):
        return name[0][0].value

    def action(self, args):
        name, parameters, precondition, effect = args
        return {'name': name[0].value, 'args': parameters, 'precondition': precondition, 'effect': effect}

    def effect(self, p_set):
        negative = list()
        positive = list()
        for p in p_set:
            try:
                if p.data == 'n_predicate':
                    negative += (p.children)
            except Exception as e:
                positive.append(p)
            print(p)
        return {'positive': positive, 'negative': negative}

    def precondition(self, args):
        return args

    number = v_args(inline=True)(float)


sample_conf = open('./blocksworld.pddl', 'r').read()
grammar = open("./grammar", 'r').read()
print(sample_conf)
print(grammar)
parser = Lark(grammar, transformer=PddlToJson(), parser="lalr")
parsed = parser.parse(sample_conf)
state = State(parsed)

problem = parse_state('blocksworld', 'state_1')
state.set_init_state(problem['init'])
plan = parse_plan('blocksworld', 'state_1')
for s in plan['steps']:
    p = Predicate(**s['predicate'])
    state.perform_action(p)

# state.perform_action('move-b-to-t', ('b9', 'b4'))
print(state)
print(parser.parse(sample_conf))
f = open('out.txt', 'w')


def write_action(name, args, predicate, preconditions):
    p1 = '\n0.000000    ' + name + '('
    p2 = ','.join(args) + ' ) => '
    p3 = ''
    for p in preconditions:
        p3 += '^' + p['name'] + '(' + ','.join(p['args']) + ')'

    return p1 + p2 + predicate['name'] + '(' + ', '.join(list(predicate['args'])) + ')' + p3


def write_neg_action(name, args, predicate, preconditions):
    p1 = '\n0.000000    ' + name + '('
    p2 = ','.join(args) + ' ) => '
    p3 = ''
    for p in preconditions:
        p3 += '^' + p['name'] + '(' + ','.join(p['args']) + ')'

    return p1 + p2 + "!" + predicate['name'] + '(' + ', '.join(list(predicate['args'])) + ')' + p3


f.write("// predicate declarations")

for a in parsed['actions']:
    f.write('\n' + a['name'] + '(' + ','.join(['object'] * len(a['args'])) + ')')

for p in parsed['predicates']:
    f.write('\n' + p['name'] + ' (' + ','.join(['object'] * len(p['args'])) + ')')
f.write("\n\n// formulas: ")

for a in parsed['actions']:
    # f.write("\n\n// positives: ")
    for p in a['effect']['positive']:
        f.write(write_action(a['name'], a['args'], p, a['precondition']))
    # f.write("\n\n// negatives: ")
    for p in a['effect']['negative']:
        f.write(write_neg_action(a['name'], a['args'], p, a['precondition']))

f.write('\n\n//databae test \n\n')


def write_state(s, p):
    f.write("\n\n// new_state \n--- ")
    f.write('\n' + p.mlnCap())
    f.write(s.mlnCap())


f.write(state.mlnCap())
for s in plan['steps']:
    p = Predicate(**s['predicate'])
    state.perform_action(p)
    write_state(state, p)

# #
# # $name
# move-b-to-b
#
# # $args
# {bm,bf,bt}
#
# # Preconditions
# action(name,t) -> clear(bm,t)
# action(name,t) -> clear(bt,t)
# action(name,t) -> on(bm,bf,t)
#
# # Positive
# action(name,t) -> on(bm,bt,t+1)
# action(name,t) ->  clear(bf,t+1)
#
# # Negative
# action(name,t) -> clear(bt,t+1)
# action(name,t) -> on(bm,bf)
#
#
#
pddl = {'domain': 'blocksworld',
        'predicates': [{'name': 'clear', 'args': list({'x'})},
                       {'name': 'on-table', 'args': list({'x'})},
                       {'name': 'on', 'args': list({'x', 'y'})}],
        'actions': [
            {'name': 'move-b-to-b',
             'args': list({'bf', 'bt', 'bm'}),
             'precondition': [{'name': 'clear', 'args': list({'bm'})},
                              {'name': 'clear', 'args': list({'bt'})},
                              {'name': 'on', 'args': list({'bf', 'bm'})}],
             'effect': {
                 'positive': [{'name': 'on', 'args': list({'bt', 'bm'})},
                              {'name': 'clear', 'args': list({'bf'})}],
                 'negative': [{'name': 'clear', 'args': list({'bt'})},
                              {'name': 'on', 'args': list({'bf', 'bm'})}]}},

            {'name': 'move-b-to-t', 'args': list({'bf', 'bm'}),
             'precondition': [{'name': 'clear', 'args': list({'bm'})},
                              {'name': 'on', 'args': list({'bf', 'bm'})}],
             'effect': {
                 'positive': [{'name': 'on-table', 'args': list({'bm'})},
                              {'name': 'clear', 'args': list({'bf'})}],
                 'negative': [{'name': 'on', 'args': list({'bf', 'bm'})}]}},
            {'name': 'move-t-to-b', 'args': list({'bt', 'bm'}),
             'precondition': [{'name': 'clear', 'args': list({'bm'})},
                              {'name': 'clear', 'args': list({'bt'})},
                              {'name': 'on-table', 'args': list({'bm'})}],
             'effect': {'positive': [{'name': 'on', 'args': list({'bt', 'bm'})}],
                        'negative': [{'name': 'clear', 'args': list({'bt'})},
                                     {'name': 'on-table', 'args': list({'bm'})}]}}]}


class freeze:
    def __init__(self):
        self.list = []
        self.unique = set()

    def __getitem__(self, item):
        return self.list[item]

    def __add__(self, other):
        if other in self.unique:
            return
        self.list.append(other)
        self.unique.add(other)

    def __hash__(self):
        return hash(str(self.list))
